[{"uri":"https://dykstrom.github.io/mazela-man-web/home/","title":"Mazela-Man","tags":[],"description":"","content":"FXGL Tutorial In this tutorial we will build a simple game using FXGL - a Java / JavaFX / Kotlin Game Library. FXGL is built on top of JavaFX, but you don\u0026rsquo;t need to know JavaFX to follow the tutorial. We will use version 11.13 of FXGL.\nThe tutorial is divided into a number of chapters that each introduces a new part of the game, and usually a new part of FXGL. Each chapter builds on the previous, so it\u0026rsquo;s advisable to read and execute them in order. Each chapter is also a Maven module that contains the code for the game as it is at the beginning of the chapter, and a README file that describes the steps to perform in the chapter. Following the tutorial closely will result in code that looks like the code contained in the following chapter. Experimentation is encouraged, but if you lose your way in the process, you can always start over with a working code base in the following chapter.\nAll resources used in the tutorial, and a few extras, can be found here.\nRequirements The following pieces of software are needed to follow the tutorial:\n Java 11. FXGL version 11.13 requires Java 11 or later. Tiled 1.2.3. FXGL works best with version 1.2.3 of the Tiled map editor. You only need to install Tiled if you want to edit level files yourself. Otherwise, you can just copy the edited file from the next chapter. If you are new to Tiled, you can read the introduction on their website. IntelliJ IDEA (recommended), Eclipse, or another IDE. Maven. The tutorial is a Maven project, and you need Maven to build it. Maven may or may not be included in your IDE. If you are new to Maven, you may want to read this five minute tutorial.  You also need to clone the Git repository of the tutorial. You can do this directly in your IDE, or you can do it on the command line, and then open the tutorial as a Maven project in the IDE.\n\u0026gt; git clone https://github.com/dykstrom/mazela-man.git Getting Started The best way to start is from the beginning.\nYou can also jump directly to a specific chapter:\n 01 Handling Input 02 Physics 03 Keeping Score 04 Animation 05 Adding Enemies 06 Multiple Levels 07 Bonus Points 08 Adding Sound 09 Main Menu 10 Conclusion  Glossary Terms used in the tutorial, explained in the context of FXGL.\n bounding box - an invisible box around an entity that can be checked for collisions callback - a call from the framework to a method in your code component - an independent part of an entity that is responsible for some part of the entity\u0026rsquo;s functionality entity - a game object; an object that exists in, and can interact with, the game world facade - a class that serves as the interface to a system, hiding complex functionality from the client frame - one iteration of the game loop; all entities, and their components will be updated once per frame physics engine - a component that provides a simulation of the physical world with for example gravity and collisions tile - a small rectangular image used repeatedly to create a level or once to represent an entity time per frame (tpf) - the amount of time that has passed in the game world since the previous update  Resources  FXGL Library FXGL Example Games Game Programming Patterns  Credits Graphics by drakzlin at OpenGameArt.org. Sounds from FXGL samples, and Classic Gaming.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/introduction/","title":"Introduction","tags":[],"description":"","content":"Basic App We start with a very basic app, the \u0026ldquo;Hello, World!\u0026rdquo; of FXGL. If you run this app, called MazelaManApp, you will be presented with a window similar to this.\nThe first thing that happens here is that our main method calls GameApplication.launch to start the app. After that, FXGL is in control, and makes callbacks to initialize and run our app. A look in the GameApplication class reveals several methods that can be used to initialize input, physics and so on, but in this basic app we override only two of them, initSettings to set some basic settings like the window size, and initUI to create the single label that makes up our UI.\n@Override protected void initUI() { Label label = new Label(\u0026#34;Hello, FXGL!\u0026#34;); label.setFont(Font.font(20.0)); FXGL.addUINode(label, 350.0, 290.0); } The Label class, and the Font class used in initUI are the normal JavaFX Label and Font classes used in any JavaFX application. Thus, having some knowledge of JavaFX will help you when developing a game with FXGL, but it is not necessary.\nThe call to FXGL.addUINode will add the label at the specified location and make it visible. The class FXGL is a facade that gives us access to much of FXGL, and we will see many calls to the static methods in class FXGL.\nBasic Game Now we will turn this app into a very basic game that displays the first level and the player but not much more. We will create a level file using an external editor, and create new classes and methods to set up the level in the game.\nSome people have found it easier to start with the code from chapter 1 instead, given that the structure of the game is already in place. So as an alternative to doing the work in this introductory chapter, you can check out the code of chapter 1 while reading this text.\nCreating a Level The first thing we want to do is to create a level that can be loaded into FXGL and displayed in the main window. The level file will contain information on the images (tiles) to display in the window, and some objects that we can control or interact with. We will create and edit level files using the Tiled application.\nFolder Structure FXGL uses the Convention over Configuration paradigm, and expects resource files to be found in a certain folder structure. Let\u0026rsquo;s start by creating that folder structure in the resources folder:\nCreating the Level File An easy way to get started is to copy an \u0026ldquo;empty\u0026rdquo; level file from the main resources folder to our newly created levels folder. Copy the level file from here and give it the name \u0026ldquo;level1.tmx\u0026rdquo;. You also need to copy the tilemap file to the levels folder. The tilemap file is a PNG file that contains all the images (tiles) that we will use when designing the level. The tilemap file we are going to use looks like this.\nIf you do not have access to the Tiled application, or do not want to edit the level file yourself, you can simply copy the level file from the next chapter instead.\nEditing the Level File Tiled is not going to be the focus of this tutorial, so editing levels in Tiled will be described somewhat briefly. A level is divided into layers. Our level has two layers - a Tile Layer, and an Object Layer. On the Tile Layer, we will put the tiles that define the looks of the level, and on the Object Layer, we will put any objects that exist in the game. In FXGL, the objects are called entities. In this step, we will have only one object or entity, and that is the Player.\nYou can design your level any way you like, but mine looks like this:\nNotice the small square near the bottom of the image. That is the Player object! If you click on the Player object, the property editor on the left will display the properties of the Player object.\nSomething important to notice about the Player object is the type, which must be \u0026ldquo;Player\u0026rdquo;. That is how FXGL knows that it should spawn a Player entity when loading the level.\nWhen you are happy with your level design, save it, and return to your IDE.\nEntity Factory Entities in FXGL are created by an entity factory. We must create an entity factory that has the ability to create Player entities. Let\u0026rsquo;s call our factory MazelaManFactory to fit with the name of the app.\npublic class MazelaManFactory implements EntityFactory { @Spawns(\u0026#34;Player\u0026#34;) public Entity spawnPlayer(SpawnData data) { return FXGL.entityBuilder(data) .viewWithBBox(\u0026#34;player.png\u0026#34;) .build(); } } The spawnPlayer method of the factory is annotated with the @Spawn annotation. That is how FXGL knows what type of entity to spawn. The value of the @Spawn annotation must match the type used in Tiled exactly. In the method, we create an entity builder with some data we received, and we add a view with a bounding box to it, and finally build the entity. The SpawnData class contains the position of the entity to spawn, as well as some additional data like the width and height of the entity. However, in our case, the width and height is taken from the view.\nThe view of an entity defines how it is represented on the screen. It can be an image as in this case, but it can also be a geometrical figure like a circle. In fact, the view can be any JavaFX Node, so we could make our view a Label or a Button. The bounding box of an entity defines the outer perimeter of the entity, and is used when detecting collisions between entities.\nImages that make up the visual part of an entity are called textures. We quickly realize that we are now missing the \u0026ldquo;player.png\u0026rdquo; texture needed to make this work. Fortunately, we can copy player.png to the textures folder.\nWhile in the entity factory, let\u0026rsquo;s also add another spawn method, to create a black background for our game.\n@Spawns(\u0026#34;Background\u0026#34;) public Entity spawnBackground(SpawnData data) { return FXGL.entityBuilder(data) .view(new Rectangle(data.\u0026lt;Integer\u0026gt;get(\u0026#34;width\u0026#34;), data.\u0026lt;Integer\u0026gt;get(\u0026#34;height\u0026#34;), Color.BLACK)) .with(new IrremovableComponent()) .zIndex(-100) .build(); } This method spawns entities of type \u0026ldquo;Background\u0026rdquo; that have a view, but no bounding box. That is because the background is not supposed to interact with the other entities. To place the background firmly in the background, we give it a zIndex of -100 which will render it behind all other entities.\nLoading the Level Let\u0026rsquo;s now turn our attention to the main class, where we want to add code to actually load the level and start our game. We remove the initUI method that we don\u0026rsquo;t need at the moment, and instead add a method to initialize the game.\n@Override protected void initGame() { FXGL.getGameWorld().addEntityFactory(new MazelaManFactory()); FXGL.spawn(\u0026#34;Background\u0026#34;, new SpawnData(0, 0).put(\u0026#34;width\u0026#34;, WIDTH).put(\u0026#34;height\u0026#34;, HEIGHT)); FXGL.setLevelFromMap(\u0026#34;level1.tmx\u0026#34;); } First, we let FXGL know of our entity factory. Second, we manually spawn the background by calling the spawn method of the FXGL facade. The arguments of the version of the spawn method we use are the entity type, and the spawn data that is used to place the entity in the window. Finally, we load the level into FXGL. The setLevelFromMap method will read the level file, render the tiles, and create the entities defined as objects in the level file. It expects, as previously mentioned, the level file to exist in a specific folder, namely \u0026ldquo;resources/assets/levels\u0026rdquo;.\nIf you run your application again, you will see something that looks like this.\nIf you instead get an error message similar to below, you probably need to run Maven to copy the resources to the target folder. Note that you need to re-run Maven each time you have added new assets to the chapter you are working on.\nYou can run Maven in your IDE, or on the command line. If you run from the command line, make sure that the correct Java version is first in your path. Running Maven successfully will produce output similar to this:\n\u0026gt; mvn compile [INFO] Scanning for projects... [... a lot of output ...] [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for mazela-man 0.1.0-SNAPSHOT: [INFO] [INFO] mazela-man ......................................... SUCCESS [ 0.008 s] [INFO] 00-introduction .................................... SUCCESS [ 1.441 s] [INFO] 01-chapter-1 ....................................... SUCCESS [ 0.353 s] [INFO] 02-chapter-2 ....................................... SUCCESS [ 0.416 s] [INFO] 03-chapter-3 ....................................... SUCCESS [ 0.374 s] [INFO] 04-chapter-4 ....................................... SUCCESS [ 0.360 s] [INFO] 05-chapter-5 ....................................... SUCCESS [ 0.368 s] [INFO] 06-chapter-6 ....................................... SUCCESS [ 0.366 s] [INFO] 07-chapter-7 ....................................... SUCCESS [ 0.439 s] [INFO] 08-chapter-8 ....................................... SUCCESS [ 0.418 s] [INFO] 09-chapter-9 ....................................... SUCCESS [ 0.376 s] [INFO] 10-chapter-10 ...................................... SUCCESS [ 0.372 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 5.478 s [INFO] Finished at: 2021-03-16T16:28:50+01:00 [INFO] ------------------------------------------------------------------------ This concludes the introduction of the tutorial. Now you can proceed to chapter 1.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/01_handling_input/","title":"01. Handling input","tags":[],"description":"","content":"Now we have set the scene for our game. The next step is to make it interactive. We want the player character to move when we press a key. FXGL has bindings for both keyboard and mouse input, but in this tutorial we will only use keyboard input.\nGetting the Player Entity To move the player entity, we first must retrieve it from the game world somehow. To do this we need to define an enum that serves as the entity type. Do not confuse the entity type with the type string used in Tiled to make FXGL spawn an entity. The enum EntityType is used when finding entities in a live game world. Let\u0026rsquo;s create a new file with the enum EntityType in it.\npublic enum EntityType { PLAYER } Now we can modify the spawnPlayer method to set this type on the entity being created. We call the builder method type.\n@Spawns(\u0026#34;Player\u0026#34;) public Entity spawnPlayer(SpawnData data) { return FXGL.entityBuilder(data) .type(EntityType.PLAYER) .viewWithBBox(\u0026#34;player.png\u0026#34;) .build(); } The spawned player will now have the entity type PLAYER, and FXGL lets us find entities by type. We add a convenience method to MazelaManApp to get the player entity.\nprivate static Entity getPlayer() { return FXGL.getGameWorld().getSingleton(EntityType.PLAYER); } Registering User Actions When we have a way to get the player entity, so it can be updated, we need to tell FXGL that we are interested in certain key presses by registering user actions for those keys. The FXGL GameApplication base class has a callback method we can override to do that. It is called initInput. In this method we can call one or more methods on the FXGL facade to register the user actions, like this:\n@Override protected void initInput() { FXGL.onKey(KeyCode.A, \u0026#34;Move Left\u0026#34;, () -\u0026gt; getPlayer().translateX(-SPEED)); ... } The code above registers a user action that runs when the A key is pressed. The name of the action is \u0026ldquo;Move Left\u0026rdquo;. This name actually has a meaning, as we will see soon. When the action runs, we get the player entity and move it some amount to the left. For this to work, we obviously need to define the constant SPEED as well.\nprivate static final int SPEED = 2; The methods translateX and translateY move the entity relative to its current location. There are also methods setX and setY that move the entity to an absolute location. Note that there is no physics involved here. There are no forces that affect the entity. It only moves when we tell it to move.\nThere are other ways to register user actions. If you want more fine-grained control of how to react to button presses, you can instead register a UserAction instance, and override the methods you need.\nFXGL.getInput().addAction(new UserAction(\u0026#34;Move Left\u0026#34;) { @Override protected void onAction() { } @Override protected void onActionBegin() { } @Override protected void onActionEnd() { } }, KeyCode.A); To finish up, here is the complete initInput method.\n@Override protected void initInput() { FXGL.onKey(KeyCode.A, \u0026#34;Move Left\u0026#34;, () -\u0026gt; getPlayer().translateX(-SPEED)); FXGL.onKey(KeyCode.D, \u0026#34;Move Right\u0026#34;, () -\u0026gt; getPlayer().translateX(SPEED)); FXGL.onKey(KeyCode.W, \u0026#34;Move Up\u0026#34;, () -\u0026gt; getPlayer().translateY(-SPEED)); FXGL.onKey(KeyCode.S, \u0026#34;Move Down\u0026#34;, () -\u0026gt; getPlayer().translateY(SPEED)); } Game Menu I mentioned before that the name of the action has a meaning, and now we will see how. FXGL has a built-in game menu that we get for free in all games. It contains sub menus for setting properties that most games need, including key bindings. So we get for free, the ability to let the user choose their own key bindings. If you want, you can also add a main menu that is displayed when the game is started.\nThe game menu is accessed by pressing the Esc key while the game is running. Try this, and then click Options and then Controls. This will display the sub menu for choosing key bindings and here you will see the action names we entered before.\nIf you try the game as it is now, you soon find a major problem. The player can move through walls! In fact, it can even move off-screen. To solve this problem we will add physics and collisions in the next chapter.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/02_physics/","title":"02. Physics","tags":[],"description":"","content":"The reason the player can move through the walls is that the walls do not \u0026ldquo;exist\u0026rdquo; in the game. As of now, they are only images, and not entities. To fix this we are going to create objects for the walls in Tiled.\nAs before, if you don\u0026rsquo;t want to use Tiled, you can copy the level file from the next chapter. The tilemap is still the same.\nStart Tiled and open the level file for the current chapter. Select the Object Layer in the Layers area, and start adding objects for the walls on top of the tiles. Try to make the wall objects fit as close as possible to the wall tiles. That becomes easier if you set snapping to \u0026ldquo;Snap to pixels\u0026rdquo; in View\u0026ndash;\u0026gt;Snapping.\nHere is a closeup of a part of my level including objects for the walls.\nNote that you need to set the type string of all wall objects to \u0026ldquo;Wall\u0026rdquo; in the property editor. This type string will again be used in the entity factory to spawn the correct entity.\nRemember to save the level file when you are done with the walls.\nWall Entities Now that we have added the walls as objects in the level file, we again turn our attention to the entity factory. Let\u0026rsquo;s add a spawn method for walls.\n@Spawns(\u0026#34;Wall\u0026#34;) public Entity spawnWall(SpawnData data) { return FXGL.entityBuilder(data) .type(EntityType.WALL) .bbox(new HitBox(BoundingShape.box(data.\u0026lt;Integer\u0026gt;get(\u0026#34;width\u0026#34;), data.\u0026lt;Integer\u0026gt;get(\u0026#34;height\u0026#34;)))) .with(new PhysicsComponent()) .build(); } We annotate this method with @Spawn(\u0026quot;Wall\u0026quot;) to match it with what is in the level file. We set the entity type to EntityType.WALL, which means we also need to add that enum constant to the enum EntityType. We create a bounding box for the wall entity using data from the SpawnData. The width and height read from SpawnData are of course the width and height we saw in the Tiled property editor. Note that wall entities do not have any view. They are invisible entities, and that is because we drew them using tiles in Tiled. Entities that remain in the same position during the entire level can be drawn in the Tiled editor, while entities that move, or appear and disappear again, must be created with a view when they are created by the entity factory.\nThe last thing to note about the new spawn method is that we give the entity a PhysicsComponent. FXGL is highly componentized, you can add any number of predefined or custom components to an entity. All components will receive callbacks when they are added or removed, and on each frame during game play. In a later chapter we will create a custom component, but the PhysicsComponent is one of the predefined components.\nAdding a PhysicsComponent to an entity means giving up control of the entity. It will now be managed by the physics engine. You can no longer move the entity by calling the translate methods. Instead, you will have to work with forces and velocities. It also means that the entity will interact with other entities managed by the physics engine. We will use that by also letting the player entity be managed by the physics engine.\nPlayer Entity Adding a PhysicsComponent for the player entity is a bit more complicated, because we want to set some properties of the player body at the same time. FXGL uses jbox2d to deal with physics, and the definitions below all relate to jbox2d. While it is beyond the scope of this tutorial to explain the entire physics system of FXGL and jbox2d, some important properties below will be described. There are many more properties to play with if you want.\n@Spawns(\u0026#34;Player\u0026#34;) public Entity spawnPlayer(SpawnData data) { PhysicsComponent physics = new PhysicsComponent(); physics.setFixtureDef(new FixtureDef().friction(0).density(0.1f)); BodyDef bd = new BodyDef(); bd.setFixedRotation(true); bd.setType(BodyType.DYNAMIC); physics.setBodyDef(bd); return FXGL.entityBuilder(data) .type(EntityType.PLAYER) .viewWithBBox(\u0026#34;player.png\u0026#34;) .with(physics) .build(); } We create a PhysicsComponent, and set a fixture on it. Fixtures contain some non-geometrical properties of physics bodies that are used for collision detection. We set the friction to 0, which means the player will glide along the walls. When you have completed this chapter, and have a working physics world, you can try to set the friction to something else, for example 0.5f, and notice what happens!\nNext, we create a body definition that holds data used to create a rigid body. By setting fixed rotation to true we prevent the body (that is, the player) from rotating when it collides with another body, and by setting the body type to DYNAMIC, we get a body that has a velocity determined by forces and is moved by the physics engine.\nFinally, we give the configured PhysicsComponent to the entity builder to attach it to the player entity.\nGravity and Forces The physics world is ruled by forces, and one of the forces that is usually present is gravity. However, we don\u0026rsquo;t want any gravity in this game, so we will set it to zero. We can initialize the physics world by overriding yet another method from GameApplication, this time the method `initPhysics (surprise, surprise). We set the gravity both horizontally and vertically to zero. Later, you can try setting it to something else, and observe the force of gravity.\n@Override protected void initPhysics() { FXGL.getPhysicsWorld().setGravity(0, 0); } As noted before, we cannot move the player entity manually any longer, when it is managed by the physics engine. Instead, we give the entity a velocity and watch it move automatically. Let\u0026rsquo;s rewrite the input handlers to access the PhysicsComponent of the player entity, and set a velocity on it.\n@Override protected void initInput() { FXGL.onKey(KeyCode.A, \u0026#34;Move Left\u0026#34;, () -\u0026gt; getPlayer().getComponent(PhysicsComponent.class).setVelocityX(-SPEED)); FXGL.onKey(KeyCode.D, \u0026#34;Move Right\u0026#34;, () -\u0026gt; getPlayer().getComponent(PhysicsComponent.class).setVelocityX(SPEED)); FXGL.onKey(KeyCode.W, \u0026#34;Move Up\u0026#34;, () -\u0026gt; getPlayer().getComponent(PhysicsComponent.class).setVelocityY(-SPEED)); FXGL.onKey(KeyCode.S, \u0026#34;Move Down\u0026#34;, () -\u0026gt; getPlayer().getComponent(PhysicsComponent.class).setVelocityY(SPEED)); } The constant SPEED is now a velocity, and not a number of pixels to move, so it has to be updated too. A suitable value for the new SPEED constant could be 150.\nWhen we run the game again, we can see that the player continues moving in the same direction until it is stopped by a wall. That is because there is no friction, and no gravity affecting it.\nThis is the end of chapter 2. In the next chapter we will make the game a bit more interesting by adding something for the player to eat.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/03_eating_and_keeping_score/","title":"03. Eating and Keeping Score","tags":[],"description":"","content":"In this chapter, we will add pills for the player to eat, handle collisions to know when a pill has been eaten, keep a score of the pills eaten, and display this score in the UI. We start as usual, in the Tiled editor. A new version of the level file, with pills added, can be copied from here.\nAdding Pills Open the level file for this chapter in Tiled, and add objects for as many pills you want in your level. Make the objects 20x20 pixels in size, like a square in the grid. This will be easier to do if you set snapping to \u0026ldquo;Snap to Grid\u0026rdquo;. Remember to set the type string of all pill objects to \u0026ldquo;Pill\u0026rdquo;. As you already know by now, we will use that string in the entity factory.\nThis is how my level looks in Tiled after adding all the pills.\nIn the entity factory, we add the corresponding spawn method.\n@Spawns(\u0026#34;Pill\u0026#34;) public Entity spawnPill(SpawnData data) { return FXGL.entityBuilder(data) .type(EntityType.PILL) .view(\u0026#34;pill.png\u0026#34;) // Make hit box a little smaller than the tile to fit the visible part of the image  .bbox(new HitBox(\u0026#34;PILL_HIT_BOX\u0026#34;, new Point2D(5, 5), BoundingShape.box(9, 9))) .collidable() .build(); } We need to create a new enum constant in EntityType, and we need to copy the pill image to the textures folder from here.\nThis time we don\u0026rsquo;t create the bounding box automatically from the image. That is because the image is 20x20 pixels, but the actual pill is only 9x9 pixels. To make the collision look better, we instead create a bounding box that is a little smaller than the image, trying to fit it to the actual pill.\nWe also call the collidable method on the builder, which is just a convenience method for adding a CollidableComponent to the entity. This lets the entity take part in FXGL\u0026rsquo;s own collision detection. We want the player entity to also be collidable, so we add that call to the entity builder for the player entity as well.\nreturn FXGL.entityBuilder(data) .type(EntityType.PLAYER) .viewWithBBox(\u0026#34;player.png\u0026#34;) .with(physics) .collidable() .build(); Collision Detection To facilitate collision detection, we update the initPhysics method to add a collision handler.\n@Override protected void initPhysics() { PhysicsWorld physics = FXGL.getPhysicsWorld(); physics.setGravity(0, 0); physics.addCollisionHandler(new CollisionHandler(EntityType.PLAYER, EntityType.PILL) { @Override protected void onCollisionBegin(Entity player, Entity pill) { pill.removeFromWorld(); } }); } The arguments to the CollisionHandler constructor are the types of entities we want to handle collisions between. The order is important here. The callback methods, like onCollisionBegin, will receive their arguments in the same order as specified when calling the constructor. In our case, we want to handle collisions between the player and a pill. We override the callback method onCollisionBegin that is called just when a collision between two objects has started. There are other callbacks like onCollision, that is called every frame while the collision is happening.\nIn the callback method, we simply remove the pill from the game world. That makes the entity disappear completely, with view and bounding box and all.\nKeeping Score The player should score a number of points for each pill eaten, and we want to keep track of that score, and display it in the UI. For that we will use a game variable. Game variables are basically just a map from String to Object, a number of global variables used throughout the game. In our case, we will only use it in the main app class, but there are benefits with using game variables that we will take advantage of later.\nWe start by initializing the score to 0. That can be done in, you guessed it, the overridden method initGameVars.\n@Override protected void initGameVars(Map\u0026lt;String, Object\u0026gt; vars) { vars.put(\u0026#34;score\u0026#34;, 0); } Next, we want to increase the score when the player eats a pill, so we update the collision handler and add a statement to do that. The inc method is a convenience method that increments (or decrements) an integer game variable.\nFXGL.inc(\u0026#34;score\u0026#34;, 10); The final step is to display the score in the game window. Now we bring back the method initUI to initialize a label to display the score.\n@Override protected void initUI() { Label scoreLabel = new Label(); scoreLabel.setTextFill(Color.LIGHTGRAY); scoreLabel.setFont(Font.font(20.0)); scoreLabel.textProperty().bind(FXGL.getip(\u0026#34;score\u0026#34;).asString(\u0026#34;Score: %d\u0026#34;)); FXGL.addUINode(scoreLabel, 20, 10); } Here we create a JavaFX label, like we did in the very first, Hello FXGL app. What is new is that we bind the text property of the label to an integer property that represents the score game variable, and at the same time transform the integer to a string. This is JavaFX magic. By binding the label text property to the score integer property, the label text will be automatically updated whenever the score is updated. No extra code to keep them in sync, no event handling. JavaFX does it all for you.\nIf you run the application again, the maze should be filled with pills, and the score should be displayed in the top left of the window.\nIn the next chapter we will add animation to the game.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/04_animation/","title":"04. Animation","tags":[],"description":"","content":"We are now going to animate our player character when it moves around the maze. To keep the animation code in one place, we begin by creating a custom component for the player.\nPlayerComponent Custom components in FXGL inherit from the class Component. Make sure to import the Component class from FXGL, and not from AWT.\npublic class PlayerComponent extends Component { ... } We add it to the player entity the same way as other components in the entity factory. Note that we no longer add a view with a bounding box to the entity. We only add the bounding box. That is because the PlayerComponent will take care of the view.\n@Spawns(\u0026#34;Player\u0026#34;) public Entity spawnPlayer(SpawnData data) { ... return FXGL.entityBuilder(data) .type(EntityType.PLAYER) .bbox(new HitBox(BoundingShape.box(20, 20))) .with(physics) .with(new PlayerComponent()) .collidable() .build(); } Before we can do any animation, we must create sprite sheets to base the animation on. Our player character will be animated differently depending on the direction, so we need several sprite sheets. These are the sprite sheets we will use:\nYou can copy them from here to the textures folder.\nAnimatedTexture An animated view in FXGL is provided by an AnimatedTexture. The AnimatedTexture performs the animation by playing an AnimationChannel that provides the data for one animation cycle. You can at any moment change the animation channel that is played by the animated texture, and thereby change the animation.\nFor the player animation, we need one animated texture, and three animation channels, one for each sprite sheet.\nprivate final AnimatedTexture texture; private final AnimationChannel left; private final AnimationChannel right; private final AnimationChannel upDown; In the `PlayerComponent constructor we create these objects.\nleft = new AnimationChannel(FXGL.image(\u0026#34;player-left.png\u0026#34;), Duration.seconds(0.5), 6); right = new AnimationChannel(FXGL.image(\u0026#34;player-right.png\u0026#34;), Duration.seconds(0.5), 6); upDown = new AnimationChannel(FXGL.image(\u0026#34;player-up-down.png\u0026#34;), Duration.seconds(0.5), 6); texture = new AnimatedTexture(upDown); Each animation channel is created with its sprite sheet image, a value that specifies the duration of a single animation cycle, and the number of frames in an animation cycle. The animation channel automatically splits the sprite sheet into frame images based on the number of frames specified. So our sprite sheets will be split into six images each. There are other constructors in the AnimationChannel class. You can for example specify the frame images as a list of separate images instead of a sprite sheet. You can also specify the first and last image to use, if you have a bigger sprite sheet, where not all images should be used.\nThe animated texture is created with its default animation channel. This channel will be played if you later call the play method without specifying a new channel. The texture has not yet been attached as a view to the entity. That is because the entity has not yet been created. We attach the texture to the view when the PlayerComponent is later added to the entity.\n@Override public void onAdded() { entity.getViewComponent().addChild(texture); texture.loopAnimationChannel(upDown); } This code gets the view component of the entity, and adds the animated texture as a child to it. It also starts playing the upDown animation in a loop. If you want to play an animation only once, there are play methods that you can use instead.\nThe Component class also has other callback methods that you can override. The method onRemoved is called right before the component is removed from the entity, and the method onUpdate is called each frame during game play\nIf you run the app now, you\u0026rsquo;ll see that although the player is animated, the same animation cycle is played all the time. We need to add some more code to change animation according to direction. Let\u0026rsquo;s add methods for changing direction to the PlayerComponent. The left method looks like this.\npublic void left() { if (texture.getAnimationChannel() != left) { texture.loopAnimationChannel(left); } } If the animation channel is not already equal to left, we make it so. Why the if statement? Can\u0026rsquo;t we just always set it to left in the left method? No, because that would cause the animation to restart every time we call this method. So if the user keeps pressing the A key, there would be no animation, just the first frame over and over.\nWe can add the corresponding methods for the other directions.\npublic void right() { if (texture.getAnimationChannel() != right) { texture.loopAnimationChannel(right); } } public void up() { if (texture.getAnimationChannel() != upDown) { texture.loopAnimationChannel(upDown); } } public void down() { if (texture.getAnimationChannel() != upDown) { texture.loopAnimationChannel(upDown); } } Of course, nothing at all will happen if we don\u0026rsquo;t call these new methods. We need to call them from the input handlers. The input handler for the A key will now look like:\nFXGL.onKey(KeyCode.A, \u0026#34;Move Left\u0026#34;, () -\u0026gt; { getPlayer().getComponent(PhysicsComponent.class).setVelocityX(-SPEED); getPlayer().getComponent(PlayerComponent.class).left(); }); We get the PlayerComponent from the player entity and call the left method.\nNow we are done! The animation works as expected. However, since we now have a PlayerComponent, we can refactor our code and move more of the player related code into the PlayerComponent. We already have methods called left, right, up, and down in the PlayerComponent. Let\u0026rsquo;s move the actual moving of the entity into these methods as well.\nprivate PhysicsComponent physics; public void left() { physics.setVelocityX(-SPEED); if (texture.getAnimationChannel() != left) { texture.loopAnimationChannel(left); } } public void right() { physics.setVelocityX(SPEED); if (texture.getAnimationChannel() != right) { texture.loopAnimationChannel(right); } } public void up() { physics.setVelocityY(-SPEED); if (texture.getAnimationChannel() != upDown) { texture.loopAnimationChannel(upDown); } } public void down() { physics.setVelocityY(SPEED); if (texture.getAnimationChannel() != upDown) { texture.loopAnimationChannel(upDown); } } By default, the PhysicsComponent will be injected into the PlayerComponent, so it will be available to us there. You can turn this feature off by overriding a method in Component if you want to improve the speed of entity creation.\nThe refactoring will make the initInput method look better again.\n@Override protected void initInput() { FXGL.onKey(KeyCode.A, \u0026#34;Move Left\u0026#34;, () -\u0026gt; getPlayer().getComponent(PlayerComponent.class).left()); FXGL.onKey(KeyCode.D, \u0026#34;Move Right\u0026#34;, () -\u0026gt; getPlayer().getComponent(PlayerComponent.class).right()); FXGL.onKey(KeyCode.W, \u0026#34;Move Up\u0026#34;, () -\u0026gt; getPlayer().getComponent(PlayerComponent.class).up()); FXGL.onKey(KeyCode.S, \u0026#34;Move Down\u0026#34;, () -\u0026gt; getPlayer().getComponent(PlayerComponent.class).down()); } In the next chapter we will add an enemy with simple AI.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/05_adding_enemies/","title":"05. Adding Enemies","tags":[],"description":"","content":"Our current game is not much of a challenge. We can make it harder by adding an enemy or two. This will involve more design in Tiled, adding new images, creating a new component with some very limited AI, and creating new collision handlers.\nPosition Enemies on the Map We begin our work in Tiled as usual. It is also possible to copy the finished level file from the next level as usual. Otherwise, open the level file for the current chapter in Tiled, and add an enemy object. You can of course add any number of enemies, but I will settle for one, given the design of my level.\nThe new object has a little name tag above it. The enemy objects need names to keep them apart. We will use the name later when loading textures for the enemy entity. You enter the name, as well as the type, in the Tiled property editor. For reasons unknown, I have chosen to call this object \u0026ldquo;blinky\u0026rdquo;.\nAdding Images The images we will use for enemy blinky look like this:\nCopy them to the textures folder from the main resources folder. If you want more than one enemy, we have you covered. The resources folder also contains images for pinky, inky, and clyde.\nEntity Factory Next we want to create a spawn method for enemies. In the MazelaManFactory, we add:\n@Spawns(\u0026#34;Ghost\u0026#34;) public Entity spawnGhost(SpawnData data) { return FXGL.entityBuilder(data) .type(EntityType.GHOST) .bbox(new HitBox(BoundingShape.box(20, 20))) .with(new GhostComponent(data.get(\u0026#34;name\u0026#34;), data.getX(), data.getY())) .collidable() .build(); } Here we build a collidable entity of type GHOST (which must be added to the EntityType enum) with a GhostComponent. When creating the GhostComponent instance, we provide it with parts of the spawn data entered in Tiled. Our next task will be to create the GhostComponent class.\nGhostComponent We already know how a component class should look. It should inherit Component, and if it handles the entity view, it should add a texture in the onAdded callback method. Here we use the name of the enemy to load the correct images.\npublic class GhostComponent extends Component { private final String name; private final double x; private final double y; private final Texture left; private final Texture right; private final Texture upDown; public GhostComponent(String name, double x, double y) { this.name = name; this.x = x; this.y = y; left = FXGL.texture(name + \u0026#34;-left.png\u0026#34;); right = FXGL.texture(name + \u0026#34;-right.png\u0026#34;); upDown = FXGL.texture(name + \u0026#34;-up-down.png\u0026#34;); } @Override public void onAdded() { entity.getViewComponent().addChild(upDown); } } Running the game now will provide us with a nice, albeit very static enemy.\nAdding AI To make blinky move, we will add an update method, and very limited AI. By overriding the onUpdate method, we can move the ghost entity a little every frame.\nprivate static final double SPEED = 100.0; private double dx = 0.0; private double dy = -SPEED; @Override public void onUpdate(double tpf) { entity.translateX(dx * tpf); entity.translateY(dy * tpf); } You may have noted that we did not set any PhysicsComponent on the ghost entity. Therefore, the ghost entity is not controlled by the physics engine. Instead, we control it ourselves by calling the translate methods.\nThe argument to the onUpdate method, tpf, means \u0026ldquo;time per frame\u0026rdquo;. That is the amount of time in seconds that is spent on each frame and will vary depending on the speed of the computer. Dividing 1 by the time per frame gives the number of frames per second, or FPS.\nThe time per frame can be used to make an entity move with a constant speed independent of the speed of the computer. By multiplying dx and dy with tpf, we will move the entity at a constant speed even if the FPS varies. And the FPS will vary depending on what else happens in the game, and depending on when the Java just-in-time compiler kicks in.\nNow our enemy will move, but only in one direction, and as the player before, it will move through the walls.\nCollision Detection The player and the enemies are already collidable, but the walls are not. A small update to the spawnWall method fixes that.\n@Spawns(\u0026#34;Wall\u0026#34;) public Entity spawnWall(SpawnData data) { return FXGL.entityBuilder(data) .type(EntityType.WALL) .bbox(new HitBox(BoundingShape.box(data.\u0026lt;Integer\u0026gt;get(\u0026#34;width\u0026#34;), data.\u0026lt;Integer\u0026gt;get(\u0026#34;height\u0026#34;)))) .with(new PhysicsComponent()) .collidable() .build(); } Next, we add a collision handler for a ghost and a wall. In initPhysics, we add:\nphysics.addCollisionHandler(new CollisionHandler(EntityType.GHOST, EntityType.WALL) { @Override protected void onCollisionBegin(Entity ghost, Entity wall) { ghost.getComponent(GhostComponent.class).turn(); } }); Again, the order of the constructor arguments to CollisionHandler decides the order of the arguments to the callback method onCollisionBegin. The new collision handler gets the GhostComponent and calls a method turn on it. So we return to the GhostComponent, and create the turn method and its helper method getRandomSpeedAndDirection.\nprivate static final Random RANDOM = new Random(); public void turn() { if (dx \u0026lt; 0.0) { entity.translateX(2); dx = 0.0; dy = getRandomSpeedAndDirection(); } else if (dx \u0026gt; 0.0) { entity.translateX(-2); dx = 0.0; dy = getRandomSpeedAndDirection(); } else if (dy \u0026lt; 0.0) { entity.translateY(2); dy = 0.0; dx = getRandomSpeedAndDirection(); } else { entity.translateY(-2); dy = 0.0; dx = getRandomSpeedAndDirection(); } if (dx \u0026lt; 0.0) { entity.getViewComponent().removeChild(upDown); entity.getViewComponent().addChild(left); } else if (dx \u0026gt; 0.0) { entity.getViewComponent().removeChild(upDown); entity.getViewComponent().addChild(right); } else { entity.getViewComponent().removeChild(left); entity.getViewComponent().removeChild(right); entity.getViewComponent().addChild(upDown); } } private double getRandomSpeedAndDirection() { return RANDOM.nextBoolean() ? SPEED : -SPEED; } There seems to be much going on here, but in reality we are just doing almost the same thing for a number of different cases. The first if-else statement has to do with changing the direction of the entity by setting dx and dy to new values. The second if-else statement changes the view of the entity depending on the direction it moves.\nThe logic of the first if-else statement is if the entity is moving left or right, it will randomly turn up or down, and if the entity is moving up or down, it will randomly turn left or right. That is all there is to the AI of the ghosts in this implementation. \u0026ldquo;But wait, you say, what about the entity.translateX(2) and similar statements?\u0026rdquo; Yes, that is a hack to overcome a limitation in the collision detection. Since we are not using the physics engine to detect the collisions between ghosts and walls, the entities do not stop automatically when they collide. When the onCollisionBegin method is called, the entities have already collided, and are now overlapping in the game world. If we just change direction and move on, the collision will still be going on, which will cause problems with the next collision. To avoid that, we move the entity back two pixels in the direction it came from, which ends the collision. This does not feel like an optimal solution, but it is some kind of solution. Probably, the real solution is to use the physics engine for ghost-wall collisions as well\u0026hellip;\nThe second if-else statement does not contain any mysteries. Depending on the direction the entity is now travelling we add the correct texture to the view, after first removing the old texture to avoid having duplicate textures in the view.\nPlayer-Ghost Collisions Hopefully, the ghost or ghosts can now move around in the maze, but we also want to detect collisions between the player and a ghost. In case of a player-ghost collection, both entities should respawn at their original locations. The GhostComponent already knows its original location, but the PlayerComponent must be updated to know that too.\nprivate final double x; private final double y; public PlayerComponent(double x, double y) { this.x = x; this.y = y; ... } The spawnPlayer method must also be updated to provide the constructor with x and y like the spawnGhost method already does.\nWe can now add methods to respawn entities in both PlayerComponent and GhostComponent. Respawning is as easy as removing the entity from the world and spawning it again using the saved location, and, in the case of ghosts, the saved name.\npublic class PlayerComponent extends Component { ... public void respawn() { entity.removeFromWorld(); FXGL.spawn(\u0026#34;Player\u0026#34;, new SpawnData(x, y)); } } public class GhostComponent extends Component { ... public void respawn() { entity.removeFromWorld(); FXGL.spawn(\u0026#34;Ghost\u0026#34;, new SpawnData(x, y).put(\u0026#34;name\u0026#34;, name)); } } The final step is adding a collision handler that handles player-ghost collisions. In initPhysics we add:\nphysics.addCollisionHandler(new CollisionHandler(EntityType.PLAYER, EntityType.GHOST) { @Override protected void onCollisionBegin(Entity player, Entity ghost) { FXGL.getGameWorld() .getEntitiesByType(EntityType.GHOST) .forEach(entity -\u0026gt; entity.getComponent(GhostComponent.class).respawn()); player.getComponent(PlayerComponent.class).respawn(); } }); In this collision handler we respawn not only the ghost that collided, but all ghosts, making all ghosts return to their original locations. Here we get all entities of type GHOST, but there are many more ways to get entities from the game world. For example, you can get the closest entity to a point, or all entities within an area. You can also get all entities that satisfy a predicate. All depends on the type of game you are working on.\nThat\u0026rsquo;s all for this chapter. In the next chapter we will add a second level to the game.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/06_second_level/","title":"06. A Second Level","tags":[],"description":"","content":"Adding a second level to the game involves mostly work with designing the level in Tiled. In addition to that, we also need to do some work in the code to keep track of the pills eaten and the current level.\nDesigning the Level To design a new level, it is probably easiest to copy your existing level and update it. Redesign the maze in any way you like, position the player, the ghost(s), and the pills by creating objects with type and name. Name the new level file \u0026ldquo;level2.tmx\u0026rdquo;.\nIf you don\u0026rsquo;t feel like doing all that work in Tiled, you can copy a ready-made level2.tmx file. The maze in this file looks like this:\nThe Player object is the highlighted object close to the bottom.\nIf you added any new ghosts to the new level, you will have to copy the textures for them to the textures folder. All available resources can be found in the main resources folder. I added \u0026ldquo;pinky\u0026rdquo;, who looks like this:\nStart Level To make it easier to test the game, we will add a command line argument to specify the start level. Then we can easily start playing on level 2 to test that level.\nThere are libraries for handling command line arguments, but we will make it as easy as possible here, and parse a single optional argument ourselves. We add a static variable to save the start level, and make a small addition to the main method.\nprivate static int startLevel = 1; public static void main(String[] args) { if (args.length \u0026gt; 0) { startLevel = Integer.parseInt(args[0]); } launch(args); } We save the current level as a game variable, and create a new method that initializes a level. The initGame method now calls initLevel instead of initializing the level itself. The geti method is again a convenience method in class FXGL for getting the value of an integer game variable.\n@Override protected void initGameVars(Map\u0026lt;String, Object\u0026gt; vars) { vars.put(\u0026#34;level\u0026#34;, startLevel); vars.put(\u0026#34;score\u0026#34;, 0); } @Override protected void initGame() { FXGL.getGameWorld().addEntityFactory(new MazelaManFactory()); initLevel(); } private void initLevel() { FXGL.spawn(\u0026#34;Background\u0026#34;, new SpawnData(0, 0).put(\u0026#34;width\u0026#34;, WIDTH).put(\u0026#34;height\u0026#34;, HEIGHT)); FXGL.setLevelFromMap(\u0026#34;level\u0026#34; + FXGL.geti(\u0026#34;level\u0026#34;) + \u0026#34;.tmx\u0026#34;); } We want the level value to be visible in the UI, so we update the initUI method and add code for a new label. This is very similar to the score label. We create a JavaFX label, set some properties, and bind its text property to the property of the level game variable. In the bind call we also transform the level property of type Integer to a text property of type String. Finally, we add the label as a node at a specified position.\nLabel levelLabel = new Label(); levelLabel.setTextFill(Color.LIGHTGRAY); levelLabel.setFont(Font.font(20.0)); levelLabel.textProperty().bind(FXGL.getip(\u0026#34;level\u0026#34;).asString(\u0026#34;Level: %d\u0026#34;)); FXGL.addUINode(levelLabel, 720, 10); Counting Pills We want the player to progress to the next level, when all pills have been eaten. Since we don\u0026rsquo;t know from the start how many they are, we have to count them. Let\u0026rsquo;s do this in the initLevel method after we have loaded the level. We simply get all entities of type PILL, count them, and store the result in a game variable.\n// Store the number of pills on this level  FXGL.set(\u0026#34;pills\u0026#34;, FXGL.getGameWorld().getEntitiesByType(EntityType.PILL).size()); Next, we modify the player-pill collision handler to decrease the number of pills each time the player eats a pill. There is no dec convenience method, so instead we increase the number of pills with -1. If the number of remaining pills has reached 0, we start the next level.\n@Override protected void onCollisionBegin(Entity player, Entity pill) { pill.removeFromWorld(); FXGL.inc(\u0026#34;score\u0026#34;, 10); FXGL.inc(\u0026#34;pills\u0026#34;, -1); if (FXGL.geti(\u0026#34;pills\u0026#34;) == 0) { FXGL.inc(\u0026#34;level\u0026#34;, 1); Platform.runLater(() -\u0026gt; initLevel()); } } The call to initLevel is enclosed in a call to Platform.runLater. This is done to let the current event handler finish executing before we delete the current scene and replace it with something entirely different. Platform is a JavaFX class, and the same technique is used when working with events in JavaFX applications.\nThe observant reader has by now figured out that the game will crash when the player has made it through level 2. Don\u0026rsquo;t worry! We will fix that issue in chapter 9.\nAdding a new level is done. This is how my level design look in action.\nNow proceed to the next chapter\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/07_bonus_points/","title":"07. Bonus Points","tags":[],"description":"","content":"In this chapter we will add cherries that enable the player to earn bonus points. The cherries will spawn at well-defined spawn-points at random points in time, and remain visible for ten seconds before they disappear.\nAdding Cherries in Tiled As usual, we start in Tiled. This time, you need to edit both level 1 and level 2, and any additional levels you may have created. Or you can copy the level files from the next chapter. We will not add any cherries, but rather cherry spawn-points to the level files. The spawn-points will exist through the whole level even though the spawned cherries will not. I added spawn-points in the corners of the level 1 maze, and set the type string to \u0026ldquo;CherrySpawnPoint\u0026rdquo;.\nWe also need to copy the cherry image to the textures folder.\nEntity Factory The next step is as always to create a new spawn method for the object we added to the level file. In this case we will actually add two spawn methods - one for the cherry spawn-point, and one for the cherries.\n@Spawns(\u0026#34;CherrySpawnPoint\u0026#34;) public Entity spawnCherrySpawnPoint(SpawnData data) { return FXGL.entityBuilder(data) .with(new CherrySpawnComponent()) .build(); } @Spawns(\u0026#34;Cherry\u0026#34;) public Entity spawnCherry(SpawnData data) { return FXGL.entityBuilder(data) .type(EntityType.CHERRY) .viewWithBBox(\u0026#34;cherry.png\u0026#34;) .collidable() .build(); } The cherry spawn-point is an invisible entity, so it does not have any view. The only thing it does have is a CherrySpawnComponent, which we will create shortly. The cherries are collidable entities with a view, and a bounding box created from the view. The cherries are of entity type CHERRY to enable them to be picked up by the player. The EntityType enum constant CHERRY must also be created.\nCherrySpawnComponent Here is the entire CherrySpawnComponent:\npublic class CherrySpawnComponent extends Component { private static final Random RANDOM = new Random(); @Override public void onUpdate(double tpf) { // Spawn a cherry randomly if there is not a cherry already  if (RANDOM.nextInt(1000) == 0 \u0026amp;\u0026amp; noCherryAt(entity.getX(), entity.getY())) { Entity cherry = FXGL.spawn(\u0026#34;Cherry\u0026#34;, new SpawnData(entity.getX(), entity.getY())); despawnLater(cherry); } } private void despawnLater(Entity cherry) { FXGL.getGameTimer().runOnceAfter(cherry::removeFromWorld, Duration.seconds(10)); } private boolean noCherryAt(double x, double y) { return FXGL.getGameWorld().getEntitiesByType(EntityType.CHERRY) .stream() .noneMatch(e -\u0026gt; e.getX() == x \u0026amp;\u0026amp; e.getY() == y); } } The CherrySpawnComponent has an onUpdate method that is called every frame. Every time that method is called, there is one chance in 1000 to spawn a cherry, if there is not already a cherry at that position. Note that the component does not need to remember its own position, because it has access to the entity it is part of, and the entity has the position.\nIf we are lucky, and a cherry should be spawned, onUpdate calls one of the spawn methods in FXGL, which in turn uses some reflection magic to call the spawnCherry method in our entity factory. We get back a reference to the created entity, and this reference is passed to a method that starts a timer that triggers after 10 seconds, and then removes the cherry again.\nUsing the built-in game timer has the advantage that the call to removeFromWorld is performed on the JavaFX Application Thread. JavaFX and FXGL require all calls to the framework to be made on the JavaFX Application Thread to work properly. Normally, that is no problem because all callback methods are called on this thread, but creating your own timer would involve a background thread.\nThe helper method noCherryAt just checks that there is no entity of type CHERRY at the specified position. An alternative implementation of this method could have retrieved all entities at the specified position using getEntitiesAt and then checked that none of them was of type CHERRY.\nCollision Handling The player-cherry collision handler is very straight forward, and I almost feel it unnecessary to state it here, but anyway, here it is:\nphysics.addCollisionHandler(new CollisionHandler(EntityType.PLAYER, EntityType.CHERRY) { @Override protected void onCollisionBegin(Entity player, Entity cherry) { cherry.removeFromWorld(); FXGL.inc(\u0026#34;score\u0026#34;, 100); } }); This completes this chapter. Move on to the next chapter where we will add sound to the game.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/08_adding_sounds/","title":"08. Adding Sound","tags":[],"description":"","content":"In this chapter we will add sound to the game, which is rather simple, given that FXGL has a convenience method play that takes the name of a sound asset and plays it. FXGL supports two types of sound - .wav files for sound effects, and .mp3 files for background music. The play method automatically plays the sound as a sound effect or as background music depending on the file extension. If you need more control over audio, you can also retrieve a reference to the audio player using FXGL.getAudioPlayer.\nSound Assets The sound assets belong in the folder \u0026ldquo;assets/sounds\u0026rdquo;. There are a number of sound assets to copy from the main resources folder:\n cherry.wav - when eating a cherry death.wav - when colliding with a ghost level.wav - when levelling up pill.wav - when eating a pill  Calling Play All calls to FXGL.play belong in the collision handlers. For example, here is the player-pill collision handler as it looks with sound effects added:\n@Override protected void onCollisionBegin(Entity player, Entity pill) { FXGL.play(\u0026#34;pill.wav\u0026#34;); pill.removeFromWorld(); FXGL.inc(\u0026#34;score\u0026#34;, 10); FXGL.inc(\u0026#34;pills\u0026#34;, -1); if (FXGL.geti(\u0026#34;pills\u0026#34;) == 0) { FXGL.inc(\u0026#34;level\u0026#34;, 1); FXGL.play(\u0026#34;level.wav\u0026#34;); Platform.runLater(() -\u0026gt; initLevel()); } } This was a short chapter, but then sound in FXGL is not very complicated. Now you can proceed to the next chapter, where we enable the main menu.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/09_enable_main_menu/","title":"09. Enable Main Menu","tags":[],"description":"","content":"We have already seen the in-game menu that you get for free in FXGL. There is also a main menu that is displayed when the app starts, but it is not enabled by default. We will enable the main menu, and also add functionality to return to the main menu after a game has finished.\nEnabling the main menu is as easy as a single line in initSettings. Check out the GameSettings class for other settings you can set, for example the seed for the random number generator.\nsettings.setMainMenuEnabled(true); If you start the application now, it will begin by displaying the main menu.\nCounting Lives We want to return to the main menu when the game is over. The game can end in two ways. Either the player runs out of lives, or the player finishes the last level. To implement the first, we need to keep track of the number of lives left. That means a new game variable that we initialize in initGameVars, a new UI label that we create in initUI, and some counting in a collision handler.\nvars.put(\u0026#34;lives\u0026#34;, 3); Label livesLabel = new Label(); livesLabel.setTextFill(Color.LIGHTGRAY); livesLabel.setFont(Font.font(20.0)); livesLabel.textProperty().bind(FXGL.getip(\u0026#34;lives\u0026#34;).asString(\u0026#34;Lives: %d\u0026#34;)); FXGL.addUINode(livesLabel, 640, 10); physics.addCollisionHandler(new CollisionHandler(EntityType.PLAYER, EntityType.GHOST) { @Override protected void onCollisionBegin(Entity player, Entity ghost) { FXGL.play(\u0026#34;death.wav\u0026#34;); FXGL.inc(\u0026#34;lives\u0026#34;, -1); if (FXGL.geti(\u0026#34;lives\u0026#34;) \u0026gt; 0) { FXGL.getGameWorld() .getEntitiesByType(EntityType.GHOST) .forEach(entity -\u0026gt; entity.getComponent(GhostComponent.class).respawn()); player.getComponent(PlayerComponent.class).respawn(); } else { gameOver(false); } } }); Now, when the player collides with a ghost, we decrease the number of lives. If there are still lives left, we respawn the player and ghosts like before. If the number of lives has reached 0, we instead call the gameOver method that we will create shortly.\nHowever, we will first make some changes to the code handling levels. We want to call the gameOver method also when the player has finished the last level. We could create a constant that holds the number of levels in the game, but then we would have to update that constant whenever we add a new level. Instead, we settle for a more dynamic option to catch the exception that is thrown when the next level is not found. Now we can just create a new level file, and the game will automatically use that level.\nInstead of calling setLevelFromMap directly from initLevel, we call a new method setLevelFromMapOrGameOver.\nprivate void initLevel() { FXGL.spawn(\u0026#34;Background\u0026#34;, new SpawnData(0, 0).put(\u0026#34;width\u0026#34;, WIDTH).put(\u0026#34;height\u0026#34;, HEIGHT)); FXGL.setLevelFromMapOrGameOver(); // Store the number of pills on this level  FXGL.set(\u0026#34;pills\u0026#34;, FXGL.getGameWorld().getEntitiesByType(EntityType.PILL).size()); } private void setLevelFromMapOrGameOver() { try { setLevelFromMap(\u0026#34;level\u0026#34; + FXGL.geti(\u0026#34;level\u0026#34;) + \u0026#34;.tmx\u0026#34;); } catch (IllegalArgumentException e) { gameOver(true); } } The exception we can catch is IllegalArgumentException which is a bit unspecific, but it will have to do. If we catch the exception, we also call the gameOver method, but this time with parameter true.\nIn the gameOver method we display a message dialog before returning to the main menu.\nprivate void gameOver(boolean reachedEndOfGame) { StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;Game Over!\\n\\n\u0026#34;); if (reachedEndOfGame) { builder.append(\u0026#34;You have reached the end of the game!\\n\\n\u0026#34;); } builder.append(\u0026#34;Final score: \u0026#34;) .append(FXGL.geti(\u0026#34;score\u0026#34;)) .append(\u0026#34;\\nFinal level: \u0026#34;) .append(FXGL.geti(\u0026#34;level\u0026#34;)); FXGL.getDialogService().showMessageBox(builder.toString(), () -\u0026gt; FXGL.getGameController().gotoMainMenu()); } The boolean parameter tells us if the player reached the end of the game, or just died. We want to display slightly different messages in the two cases. To display the dialog to the player, we use the FXGL DialogService that we get from the FXGL facade. Besides showMessageBox that we use, the dialog service provides several other types of dialogs, like input dialogs, error dialogs, and progress dialogs. The showMessageBox method we use take two input parameters. The first is the text to display, and the second is a Runnable to run when the player clicks the OK button. In our case, the runnable we provide gets the GameController from the facade, and tells it to go to the main menu. The GameController can also do much more, like pausing the game engine or display a loading screen.\nRunning the game again, and running out of lives, will now produce something like this:\nThis is the end of this chapter. Now you can proceed to the next chapter, which currently is the end of the tutorial.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/10_end_of_tutorial/","title":"10. End of Tutorial","tags":[],"description":"","content":"This ends the tutorial. Now we have a simple game with physics, sound, and multiple levels. There are still features missing, and if you want to continue exploring FXGL you can use this game as a starting point. In any case, I wish you luck in your future game creation!\nSome obvious features to add or improve:\n Power pills that enable the protagonist to hunt the ghosts Improved ghost AI - each ghost having its own personality Keeping a high score (the FXGL SaveLoadService may come in handy here)  FXGL contains much more than we have covered in this tutorial. Some examples of functionality that we have not looked at:\n Event bus Mouse support Parallax backgrounds Cutscenes Achievement system Notifications Advanced AI using decision trees Multiplayer support and networking Support for web and mobile  On the FXGL GitHub pages you can find links to more tutorials, both in written format, and in the form of YouTube videos.\n"},{"uri":"https://dykstrom.github.io/mazela-man-web/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://dykstrom.github.io/mazela-man-web/","title":"Home","tags":[],"description":"","content":"  Mazela-Man   Introduction   01. Handling input   02. Physics   03. Eating and Keeping Score   04. Animation   05. Adding Enemies   06. A Second Level   07. Bonus Points   08. Adding Sound   09. Enable Main Menu   10. End of Tutorial   window.location.replace(\"home\");   "},{"uri":"https://dykstrom.github.io/mazela-man-web/tags/","title":"Tags","tags":[],"description":"","content":""}]